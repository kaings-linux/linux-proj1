// to create multiple directories using one command, we can use curly brackets "{" "}"
// the following command will create directories: jan_2000 ~ jan_2005, feb_2000 ~ feb_2005, ... , dec_2000 ~ dec_2005 
mkdir {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2000,2001,2002,2003,2004,2005}

OR

mkdir {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2000..2005}           --> shorthand version


// to create multiple files within multiple directories using curly brackets
mkdir {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2000..2005}                    --> cannot `touch` if directory not exist
touch {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2000..2005}/file{1..100}.txt


// to list multiple files within multiple directories using curly brackets & redirect into output.txt
ls {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2000..2005}
ls {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2000..2005} > output.txt


// create multiple files in current directory using curly brackets
touch file{1..10}.txt
touch file{A..F}.txt
touch file{a,b,c,d,e}.txt


// use wildcard ?, *, [] in linux file system
// list file name file1.txt, file2.txt, filea.txt, fileb.txt, filec.txt
ls file[1-2a-c].txt           --> use regex


// remove directory
// `rmdir` ... only remove empty directory
// `rm`    ... remove files
// `rm -r` ... remove recursively, remove directory & files within it


// copy recursively
// `cp -r sourcefolder/ destinationfolder/` ... copy all content frm 'sourcefolder' to 'destinationfolder'


// ================ using locate ================ 
// might need to install package 'locate' & 'mlocate': apt-get install mlocate locate OR apt install mlocate locate
// basically how it works: 'locate' command will locate/search whatever we ask in the 'mlocate' DB. mlocate is a file system DB (it maps all the file system in it)
locate *.CONF               --> zero result because no such extension of 'CONF' it is case-sensitive
locate -i *.CONF            --> locate case-insensitively, all files with extension ".conf" will be shown
locate -i --limit 5 *.CONF  --> locate case-insensitively, only 5 files with extension ".conf" will be shown
locate -S                   --> to show information of mlocate database
locate -e *.conf            --> show only files that exist (mlocate db is only updated by the filesystem once per day so there might be file that doesn't exist anymore if we only use `locate *.conf`)

// since mlocate db is only updated once per day (by crontab using updatedb), we can also run updatedb to
// make sure our locate command returns accurat result
sudo updatedb


// ================ using find ================ 
find -maxdepth 1                ... find only 1 level down, OR
find . -maxdepth 1              ... find only 1 level down ('.' means current directory)
find -type f                    ... find only file
find -type d                    ... find only directory
find -name "*.txt"              ... find by name (case-sensitive)
find -iname "*.txt"             ... find by name (case-insensitive)
find . -type f -size +10k       ... find files which size is more than 10kb
find . -type f -size -10k       ... find files which size is less than 10kb
find . -type f -size +10k | wc -l         ... find files which size is more than 10kb & count the line
find . -type f -size +10k -size -5M       ... find files which size is more than 10kb AND less than 5Mb
find . -type f -size -10k -o -size +5M    ... find files which size is less than 10kb OR more than 5Mb

find . -type f -size +10k -size -5M -exec cp {} ./destdir \;    ... find files which size is more than 10kb & less than 5Mb, and copy each one of them into 'destdir' folder
                                                                    syntax: find -exec <command - end of command is indicated by `\;`>
                                                                    --> to execute command on each one of the found item
                                                                    --> copy syntax: cp <WHAT <TOWHERE> ... e.g.: cp {} ./destdir ... `{}` in this case is filled by the result of find command

find . -type f -size +10k -size -5M -exec cp {} ./destdir \;    ... same as `-exec` option but with `-ok`, it will ask you each time each file (which is safer than `-exec`)


// FIND COMMAND EXERCISE
// create 100 files in 500 folders
mkdir haystack
mkdir haystack/folder{1..500}
touch haystack/folder{1..500}/file{1..100}

// create 1 file "needle.txt" in any of the 500 folders randomly
// randomise using `shuf` command
touch haystack/folder$(shuf -i 1-500 -n 1)/needle.txt

// find needle.txt
find haystack/ -type f -name "needle.txt"

// find needle.txt & move it to "destdir"
find haystack/ -type f -name "needle.txt" -exec mv {} ./destdir \;


// ================ using cat ================ 
cat file1.txt                                           ... to view the content of file1.txt
cat file1.txt file2.txt file3.txt file4.txt file5.txt   ... to view concatenated content of file1.txt to file5.txt
cat file[1-5].txt                                       ... to view concatenated content of file1.txt to file5.txt
cat file[1-5].txt > fileA.txt                           ... to view concatenated content of file1.txt to file5.txt & output stream to new fileA.txt


// ================ using tac & rev ================ 
cat file[1-5].txt | tac     ... tac to reverse the content vertically (content will be displayed as content of file5.txt to file1.txt)
tac fileA.txt               ... paragraph of fileA.txt will be reversed (vertically reversed)
cat file[1-5].txt | rev     ... rev to reverse the content horizontally  (e.g. people will be 'elpoep', etc)
rev fileA.txt               ... statement of fileA.txt will be reversed (horizontally reversed)


// ================ using wc, head & tail ================ 
find . | head -n 5                       ... show the first 5 lines of find command result
find . | tail -n 5                       ... show the last 5 lines of find command result
find . | wc -l                           ... show number of lines of find command result
cat file[1-5].txt | tail -n 2            ... show bottom 2 lines of content of file1.txt to file5.txt
tail -n 20 /etc/somedir/somefile.txt     ... show bottom 20 lines of the somefile.txt content


// ================ using sort ================ 
sort words.txt       ... sort ascending content of words.txt
sort -r words.txt    ... sort descending content of words.txt
sort -n nums.txt     ... sort ascending numeric content of nums.txt
sort -nr numss.txt   ... sort descending numeric content of nums.txt


// ================ using grep ================ 
grep e hello.txt       ... search within hello.txt for letter 'e'
grep -c e hello.txt    ... count within hello.txt for letter 'e' 
grep gadsby gadsbybook.txt       ... search (case-sensitively) within gadsbybook.txt for word 'gadsby' 
grep -i gadsby gadsbybook.txt    ... search (case-insensitively) within gadsbybook.txt for word 'gadsby' 
grep -c gadsby gadsbybook.txt    ... count lines (case-sensitively) within gadsbybook.txt for line contains of word 'gadsby' 
grep -ci gadsby gadsbybook.txt   ... count lines (case-insensitively) within gadsbybook.txt for line contains of word 'gadsby'
grep -cv e gadsbybook.txt        ... count lines within gadsbybook.txt for line NOT contains of letter 'e' (`-v` is for the exclusion option)


// ================ using tar, gzip, bzip2, zip ================ 
touch file{1..3}.txt
echo "demo file" > file1.txt
echo "demo file" > file2.txt
echo "demo file" > file3.txt


// create tar file (just a container file - NOT zipping yet) of file1.txt ~ file3.txt
tar -cvf archive.tar file[1-3].txt      ... `-c` (create), `-v` (verbose), `-f` (files - we need this because we specify files)
file archive.tar                        ... check the details of the file
tar -tf archive.tar                     ... allow us to check content inside tar file. `-t` (test label), `-f` (file)
tar -xvf archive.tar                    ... to extract tar file content. `-x` (extract) - opposite of `-c`


// compress tar file with gzip - gzip is faster than bzip2 but has less compression power
tar -cvf archive.tar file[1-3].txt      ... step1: create tar file
gzip archive.tar                        ... step2: compress tar file to gzip (extension .gz)
OR
tar -cvzf archive.tar.gz file[1-3].txt  ... step1&step2: create tar file & compress it using gzip

// uncompress using gzip
gunzip archive.tar.gz                   ... uncompress gz file to tar file
tar -xvzf archive.tar.gz                ... uncompress gz file & extract tar file to files (to tar file --> to files)


// compress tar file with bzip2 - bzip2 has more compression power (esp for large files) vs gzip but slower
tar -cvf archive.tar file[1-3].txt      ... step1: create tar file
bzip2 archive.tar                       ... step2: compress tar file to bzip2 (extension .bz2)
OR
tar -cvjf archive.tar.bz2 file[1-3].txt ... step1&step2: create tar file & compress it using bzip2

// uncompress using bzip2
bunzip2 archive.tar.bz2                  ... uncompress bz2 file to tar file
tar -xvjf archive.tar.bz2                ... uncompress bz2 file & extract tar file to files (to tar file --> to files)


// compress files with zip
zip archive.zip file[1-3].txt           ... compress (zip) files at once (no need to create tar file)


// ================ using bash script, crontab ================ 
// creating bash script
// - start the content of the script with `#!/<path-to-interpreter>` (in case of `bash`, points to `bash` interpreter, can be showne by `which bash`)
// - if we wanna create python script, start the content of the script with `#!/usr/bin/python3` (points to python3 interpreter)

// using crontab to run cron job
crontab -e          ... open/edit crontab

// crontab format is `m h dom mon dow command` ... <minute> <hour> <day-of-month> <month> <day-of-week> <command> (separated by white space ' ')
*     *    10    *      *      echo "Hello!" ... execute command every 10th of the month
*    14     *    *      *      echo "Hello!" ... execute command every 14:00 each day
20   11     *    *      *      echo "Hello!" ... execute command every 11:20 each day
20   11     *    JUN    SUN    echo "Hello!" ... execute command every 11:20 each day on JUN ONLY IF it is Sunday
*     *    10    JUN    MON    echo "Hello!" ... execute command on 10 JUN ONLY IF it is Monday

// advanced crontab usage
0,15,30,45      *       *       *        *       echo "Hello!" ... execute command everyday at 0min, 15mins, 30mins, 45mins
*/15            *       *       *        *       echo "Hello!" ... execute command everyday every 15mins
*/15            *       */3     *        *       echo "Hello!" ... execute command every 3days every 15mins
59             23       *       JAN,DEC  SUN     echo "Hello!" ... execute command at 23:59 on JAN & DEC ONLY IF it is Sunday



