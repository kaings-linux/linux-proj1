//to show the manual of command
//syntax: man -k <file/command>
//e.g.:
// this will show all sections manual of 'which' command.
// refer to 'Manual+Structure+Cheat+Sheet.pdf' for the sections
`man -k which`

// to show only section 1 manual of 'which' command. By default, 
// `man` command will use assume section 1 if not specified
`man 1 which`   OR   `man which`
`man ls`
`man lscpu`
`man nproc`

// ref of brackets in linux: 
// [] ... optional
// <> ... mandatory


====================== Command Input & Output ======================
// 4 possible ways to get data into & out frm command:
// - Standard Input (stream number is 0)  ... is a standard data stream
// - Standard Output (stream number is 1) ... is a standard data stream
// - Standard Error (stream number is 2)  ... is a standard data stream
// - Command Arguments   ... is NOT a data stream, e.g.: `cal 12 2017` (command that only deals with arguments they have at that moment, not data stream)


// normal standart output
cat file.txt

// redirect standard output into a file ('1' is because standard output stream number is '1', standard input is '0', standard erro is '2')
cat 1> output.txt     OR      cat > output.txt

// redirect standard error into a file
cat wrongcommand 2> erroroutput.txt

// redirect standard output by appending the content into a file (with existing content)
cat 1>> output.txt     OR      cat >> output.txt

// redirect standard error by appending the content into a file (with existing content)
cat 2>> output.txt

// redirect the standard output of the ls  command to output.txt  but at the same time 
// redirect standard error to error.txt
ls 1> output.txt 2> error.txt

// to get standard input from a file
cat 0< input.txt       OR      cat < input.txt

// to get standard input from a file & output it into another file
cat 0< input.txt 1> output.txt      OR      cat < input.txt > output.txt


// redirect standard output to another terminal
// open another new terminal & run `tty`   ... to show path of current running terminal
```
tty
/dev/pts/0
```
// on other terminal run. This will cause the content of input.txt to be 
// output to terminal on /dev/pts/0
cat 0< input.txt > /dev/pts/0


====================== Piping ======================
// taking standard output of one command & piping it to standard input of another Command

// print standard output of command `date` to file `date.txt`
date > date.txt        OR       date 1> date.txt
Mon Sep  6 09:27:00 UTC 2021

// print standard output of the day only ("Mon" only & not the full date)
// in this case, we can use pipe `|`. By piping the outuput of `date` command, pipe it to `cut` command to 
// cut out 1st element only & output it into a file. FYI we can use pipe `|` as many as we want
date | cut --delimiter=' ' --fields=1 > today.txt

// using pipe
date | cut --delimiter=' ' --fields=1
```
Mon
```

date | cut --delimiter=' ' --fields=1 | cut --delimiter 'o' --fields 1
```
M
```

// this DOES NOT work because the output is redirected into a file before it is piped to cut command
date > dateoutput.txt | cut --delimiter=' ' --fields=1

// in order to pass the data to output file & still piping it to another command 
// (a fix to above example that WON't work - `date > dateoutput.txt | cut --delimiter=' ' --fields=1`)
// the answer is by using `tee` command. It functions like a 'T' junction to pass data to standard output but
// still maintaining to stream it through the pipe
// this way, fulldate.txt will have full date content, & piping date via cut will result in 'Mon'
date | tee fulldate.txt | cut --delimiter ' ' --fields 1

// Addionally, fulldate.txt will have full date content, & day.txt will have only day of the date content
date | tee fulldate.txt | cut --delimiter ' ' --fields 1 > day.txt
```
cat fulldate.txt 
Mon Sep  6 09:45:47 UTC 2021

cat day.txt 
Mon
```


// `echo` is a command arguments (NOT data stream), it does not accept stream input.
// Therefore, the following command does not work since `echo` only accept an arguments
echo 'Hello World'        --> works!
date | echo               --> not working

// to MAKE `echo` to printout output of `date` command, we need to CONVERT output stream from
// `date` command into an argument, we use `xargs` command
date | xargs echo         --> works!

// same as `echo`, `rm` also a command arguments, it does not accept stream input. demo example,
echo 'file 1' > file1.txt 
echo 'file 2' > file2.txt
echo 'file1.txt' > filetodelete.txt
echo 'file2.txt' >> filetodelete.txt

// to delete all files listed in the file filetodelete.txt
cat filetodelete.txt | rm          --> WON'T WORK, because rm needs xargs to convert the stream output into arguments

cat filetodelete.txt | xargs rm    --> WORKS!

// another `xargs` command example
echo '12 2018' | xargs cal > caloutput.txt


====================== Aliases ======================
// we can create command aliases in file `.bash_aliases`
// syntax: alias <alias-name>='command1 -options args | command2 -options args ...'